File: ./walkdir.py

import os

# Set the directory to start from
start_dir = "."

# Create or open the output file
with open("output.txt", "w", encoding="utf-8") as output_file:
    # Walk through the directory and subdirectories
    for dirpath, dirnames, filenames in os.walk(start_dir):
        # Loop over the files in the current directory
        for filename in filenames:
            # Check if the file is a Python file
            if filename.endswith(".py"):
                # Construct the full file path
                file_path = os.path.join(dirpath, filename)
                if file_path.startswith("./.venv"):
                    continue
                
                # Open the Python file and read its contents
                with open(file_path, "r", encoding="utf-8") as py_file:
                    contents = py_file.read()
                
                # Write the file contents to the output file
                output_file.write(f"File: {file_path}\n\n")
                output_file.write(contents)
                output_file.write("\n\n")

File: ./setup.py

from setuptools import setup, find_packages

setup(
    name="module_validator",
    version="1",
    packages=find_packages(),
    entry_points={
        "console_scripts": ["module_validator = module_validator.main:main"],
        "module_validator.module": [
            "default = module_validator.main:default_output",
            "register = module_validator.main:register",
        ],
        "module_validator.embedding": [
            "embedding = module_validator.modules.embedding.embedding:embedding"
        ],
    },
    summary="Module Validator for Substrate subnet validation",
    license="MIT",
    url="https://github.com/bakobiibizo/module_validator",
    author="bakobiibizo",
    author_email="richard@agentartificial.com",
)

File: ./check_entrypoints.py

import pkg_resources

def check_entry_points(package_name):
    print(f"Entry points for {package_name}:")
    for entry_point in pkg_resources.iter_entry_points("module_validator.module"):
        if entry_point.dist.project_name == package_name:
            print(f"  {entry_point.group}: {entry_point.name} = {entry_point.module_name}:{entry_point.attrs[0]}")

if __name__ == "__main__":
    package_name = input("Enter the package name to check: ")
    check_entry_points(package_name)

File: ./module_validator/__init__.py

from .main import create_module, register, unregister


File: ./module_validator/main.py

import sys
import argparse
import importlib.metadata
from typing import Callable
from module_validator.modules.module import Module

def default_output(output:str) -> None:
    print("This is the default output", output)


def create_module(outputer_type: str, outputer: str):
    eps = importlib.metadata.entry_points().select(group='module-validator.module')
    outputers = {
        entrypoint.name: entrypoint
        for entrypoint in eps
    }
    try:
        outputer = outputers[outputer].load()
    except KeyError:
        print(f"outputer {outputer} is not available", file=sys.stderr)
        outputers_s = ", ".join(sorted(outputers))
        print(f"available outputers: {outputers_s}", file=sys.stderr)
        return 1
    return outputer(outputer_type)
        
create_module_functions: dict[str, Callable[..., Module]] = {}

def register(module_type: str, create_function: Callable[..., Module]):
    outputer = create_module(module_type, create_function)
    create_module_functions[module_type] = outputer
    
    
def unregister(module_type:str):
    create_module_functions.pop(module_type, None)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("module_type", type=str, choices=create_module_functions.keys())
    parser.add_argument("output", type=str)
    args = parser.parse_args()
    create_module_functions[args.module_type](args.output)

if __name__ == "__main__":
    exit(register("default", default_output))

File: ./module_validator/modules/__init__.py



File: ./module_validator/modules/module.py

class Module:
    def __init__(self, name: str) -> None:
        self.name = name

    def __call__(self, output: str) -> None:
        print(output)

File: ./module_validator/modules/embedding/embedding.py

import json

def embedding(output:str)->None:
    print(json.dumps({"embedding": {output: [0.1, 0.2, 0.3]}}))

File: ./module_validator/modules/embedding/__init_.py



File: ./module_validator/modules/embedding/setup.py

from setuptools import setup

setup(
    name="embedding_module",
    version="1",
    entry_points={
        "module_validator.embedding": ["embedding=module_validator.modules.embedding.embedding:embedding"],
    }
)

